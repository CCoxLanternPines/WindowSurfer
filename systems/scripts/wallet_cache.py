"""Utilities for loading and querying wallet cache data.

Loads pre-fetched trading pair information for Binance and Kraken
exchanges. The cache is expected to be generated by the Phase 1
`fetch.py --wallet_cache` command.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any

# Module level caches so we only hit the filesystem once.
_BINANCE_CACHE: Dict[str, Any] | None = None
_KRAKEN_CACHE: Dict[str, Any] | None = None


def _cache_path(exchange: str) -> str:
    """Return the cache file path for the given exchange."""
    base = os.path.join("data", "meta")
    filename = f"{exchange}_pairs.json"
    return os.path.join(base, filename)


def load_wallet_cache() -> Dict[str, Dict[str, Any]]:
    """Load wallet caches for Binance and Kraken.

    Returns a dictionary with ``binance`` and ``kraken`` keys containing the
    respective cache data. Raises ``FileNotFoundError`` if any cache file is
    missing.
    """
    global _BINANCE_CACHE, _KRAKEN_CACHE

    if _BINANCE_CACHE is None:
        path = _cache_path("binance")
        if not os.path.exists(path):
            raise FileNotFoundError(
                "Wallet cache missing, run fetch.py --wallet_cache"
            )
        with open(path, "r", encoding="utf-8") as fh:
            _BINANCE_CACHE = json.load(fh)

    if _KRAKEN_CACHE is None:
        path = _cache_path("kraken")
        if not os.path.exists(path):
            raise FileNotFoundError(
                "Wallet cache missing, run fetch.py --wallet_cache"
            )
        with open(path, "r", encoding="utf-8") as fh:
            _KRAKEN_CACHE = json.load(fh)

    return {"binance": _BINANCE_CACHE, "kraken": _KRAKEN_CACHE}


def _lookup(cache: Dict[str, Any], symbol: str, fiat: str) -> Dict[str, Any]:
    """Helper to safely extract pair information from a cache."""
    symbol = symbol.upper()
    fiat = fiat.upper()
    return cache.get(symbol, {}).get(fiat, {})


def resolve_pairs(symbol: str, fiat: str) -> Dict[str, str]:
    """Resolve trading pairs for Binance and Kraken.

    Parameters
    ----------
    symbol: str
        Asset symbol, e.g. ``"SOL"``.
    fiat: str
        Fiat symbol, e.g. ``"USDC"``.

    Returns
    -------
    dict
        Mapping containing ``binance`` and ``kraken`` pair identifiers.
    """
    caches = load_wallet_cache()
    binance_info = _lookup(caches["binance"], symbol, fiat)
    kraken_info = _lookup(caches["kraken"], symbol, fiat)

    if not binance_info or not kraken_info:
        raise ValueError(f"Pair {symbol}/{fiat} not found in wallet cache")

    return {
        "binance": binance_info.get("pair"),
        "kraken": kraken_info.get("pair"),
    }


def get_exchange_precision(symbol: str, fiat: str, exchange: str) -> Dict[str, Any]:
    """Return precision and minimum order details from the wallet cache.

    Parameters
    ----------
    symbol: str
        Asset symbol, e.g. ``"SOL"``.
    fiat: str
        Fiat symbol, e.g. ``"USDC"``.
    exchange: str
        ``"binance"`` or ``"kraken"``.
    """
    exchange = exchange.lower()
    caches = load_wallet_cache()
    if exchange not in caches:
        raise ValueError(f"Unsupported exchange: {exchange}")

    info = _lookup(caches[exchange], symbol, fiat)
    if not info:
        raise ValueError(f"Pair {symbol}/{fiat} not found for {exchange}")

    return {
        "min_order_fiat": info.get("min_order_fiat"),
        "min_order_coin": info.get("min_order_coin"),
        "price_precision": info.get("price_precision"),
        "quantity_precision": info.get("quantity_precision"),
    }

