"""Utilities for loading and querying wallet cache data.

Loads pre-fetched trading pair information for Binance and Kraken
exchanges. The cache is expected to be generated by the Phase 1
`fetch.py --wallet_cache` command.
"""

from __future__ import annotations

import json
import os
from typing import Dict, Any

# Module level caches so we only hit the filesystem once.
_BINANCE_CACHE: Dict[str, Any] | None = None
_KRAKEN_CACHE: Dict[str, Any] | None = None


FIAT_ALIASES_KRAKEN = {
    "USDC": "USD",
    "XBT": "BTC",  # Kraken uses XBT for BTC
}


def _cache_path(exchange: str) -> str:
    """Return the cache file path for the given exchange."""
    base = os.path.join("data", "meta")
    filename = f"{exchange}_pairs.json"
    return os.path.join(base, filename)


def load_wallet_cache() -> Dict[str, Dict[str, Any]]:
    """Load wallet caches for Binance and Kraken.

    Returns a dictionary with ``binance`` and ``kraken`` keys containing the
    respective cache data. Raises ``FileNotFoundError`` if any cache file is
    missing.
    """
    global _BINANCE_CACHE, _KRAKEN_CACHE

    if _BINANCE_CACHE is None:
        path = _cache_path("binance")
        if not os.path.exists(path):
            raise FileNotFoundError(
                "Wallet cache missing. Please run: python fetch.py --wallet_cache"
            )
        with open(path, "r", encoding="utf-8") as fh:
            _BINANCE_CACHE = json.load(fh)

    if _KRAKEN_CACHE is None:
        path = _cache_path("kraken")
        if not os.path.exists(path):
            raise FileNotFoundError(
                "Wallet cache missing. Please run: python fetch.py --wallet_cache"
            )
        with open(path, "r", encoding="utf-8") as fh:
            _KRAKEN_CACHE = json.load(fh)

    return {"binance": _BINANCE_CACHE, "kraken": _KRAKEN_CACHE}


def resolve_pairs(symbol: str, fiat: str) -> Dict[str, str]:
    """Resolve trading pairs for Binance and Kraken.

    Performs basic fiat alias substitution for Kraken so that ledger coins
    denominated in USDC resolve to USD markets and handles other common
    aliases.
    """
    caches = load_wallet_cache()
    binance_cache = caches["binance"]
    kraken_cache = caches["kraken"]

    symbol = symbol.upper()
    fiat = fiat.upper()

    kraken_fiat = FIAT_ALIASES_KRAKEN.get(fiat, fiat)
    kraken_key = f"{symbol}/{kraken_fiat}"
    if kraken_key not in kraken_cache:
        raise ValueError(
            f"Pair {symbol}/{fiat} (mapped to {kraken_key}) not found in Kraken wallet cache"
        )

    binance_key = f"{symbol}/{fiat}"
    if binance_key not in binance_cache:
        raise ValueError(f"Pair {symbol}/{fiat} not found in Binance wallet cache")

    return {"binance": binance_key, "kraken": kraken_key}


def get_exchange_precision(symbol: str, fiat: str, exchange: str) -> Dict[str, Any]:
    """Return precision and minimum order details from the wallet cache."""
    exchange = exchange.lower()
    caches = load_wallet_cache()
    if exchange not in caches:
        raise ValueError(f"Unsupported exchange: {exchange}")

    symbol = symbol.upper()
    fiat = fiat.upper()

    if exchange == "kraken":
        fiat = FIAT_ALIASES_KRAKEN.get(fiat, fiat)
        pair = f"{symbol}/{fiat}"
    else:
        pair = f"{symbol}/{fiat}"

    info = caches[exchange].get(pair, {})
    if not info:
        raise ValueError(f"Pair {symbol}/{fiat} not found for {exchange}")

    limits = info.get("limits", {})
    precision = info.get("precision", {})
    return {
        "min_order_fiat": limits.get("cost", {}).get("min"),
        "min_order_coin": limits.get("amount", {}).get("min"),
        "price_precision": precision.get("price"),
        "quantity_precision": precision.get("amount"),
    }

